import { DefaultError, QueryKey, OmitKeyof, QueryObserverOptions as QueryObserverOptions$1, InfiniteQueryObserverOptions as InfiniteQueryObserverOptions$1, DefaultOptions as DefaultOptions$1, QueryClientConfig as QueryClientConfig$1, QueryClient as QueryClient$1, QueryObserverResult, DefinedQueryObserverResult, InfiniteQueryObserverResult, DefinedInfiniteQueryObserverResult, MutationObserverOptions, MutateFunction, MutationObserverResult, DataTag, QueryFilters, InfiniteData, MutationFilters, MutationState, Mutation, QueriesPlaceholderDataFunction, QueryFunction, ThrowOnError } from '@tanstack/query-core';
export * from '@tanstack/query-core';
import * as solid_js from 'solid-js';
import { JSX, Accessor } from 'solid-js';

interface QueryObserverOptions<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryData = TQueryFnData, TQueryKey extends QueryKey = QueryKey, TPageParam = never> extends OmitKeyof<QueryObserverOptions$1<TQueryFnData, TError, TData, TQueryData, TQueryKey, TPageParam>, 'structuralSharing'> {
    /**
     * Set this to a reconciliation key to enable reconciliation between query results.
     * Set this to `false` to disable reconciliation between query results.
     * Set this to a function which accepts the old and new data and returns resolved data of the same type to implement custom reconciliation logic.
     * Defaults reconciliation to false.
     */
    reconcile?: string | false | ((oldData: TData | undefined, newData: TData) => TData);
}
interface InfiniteQueryObserverOptions<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryData = TQueryFnData, TQueryKey extends QueryKey = QueryKey, TPageParam = unknown> extends OmitKeyof<InfiniteQueryObserverOptions$1<TQueryFnData, TError, TData, TQueryData, TQueryKey, TPageParam>, 'structuralSharing'> {
    /**
     * Set this to a reconciliation key to enable reconciliation between query results.
     * Set this to `false` to disable reconciliation between query results.
     * Set this to a function which accepts the old and new data and returns resolved data of the same type to implement custom reconciliation logic.
     * Defaults reconciliation to false.
     */
    reconcile?: string | false | ((oldData: TData | undefined, newData: TData) => TData);
}
interface DefaultOptions<TError = DefaultError> extends DefaultOptions$1<TError> {
    queries?: OmitKeyof<QueryObserverOptions<unknown, TError>, 'queryKey'>;
}
interface QueryClientConfig extends QueryClientConfig$1 {
    defaultOptions?: DefaultOptions;
}
declare class QueryClient extends QueryClient$1 {
    constructor(config?: QueryClientConfig);
}

type FunctionedParams<T> = () => T;
interface CreateBaseQueryOptions<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> extends OmitKeyof<QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>, 'suspense'> {
    /**
     * Only applicable while rendering queries on the server with streaming.
     * Set `deferStream` to `true` to wait for the query to resolve on the server before flushing the stream.
     * This can be useful to avoid sending a loading state to the client before the query has resolved.
     * Defaults to `false`.
     */
    deferStream?: boolean;
    /**
     * @deprecated The `suspense` option has been deprecated in v5 and will be removed in the next major version.
     * The `data` property on createQuery is a SolidJS resource and will automatically suspend when the data is loading.
     * Setting `suspense` to `false` will be a no-op.
     */
    suspense?: boolean;
}
interface SolidQueryOptions<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> extends CreateBaseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey> {
}
type CreateQueryOptions<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> = FunctionedParams<SolidQueryOptions<TQueryFnData, TError, TData, TQueryKey>>;
type CreateBaseQueryResult<TData = unknown, TError = DefaultError> = QueryObserverResult<TData, TError>;
type CreateQueryResult<TData = unknown, TError = DefaultError> = CreateBaseQueryResult<TData, TError>;
type DefinedCreateBaseQueryResult<TData = unknown, TError = DefaultError> = DefinedQueryObserverResult<TData, TError>;
type DefinedCreateQueryResult<TData = unknown, TError = DefaultError> = DefinedCreateBaseQueryResult<TData, TError>;
interface SolidInfiniteQueryOptions<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryData = TQueryFnData, TQueryKey extends QueryKey = QueryKey, TPageParam = unknown> extends OmitKeyof<InfiniteQueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey, TPageParam>, 'queryKey' | 'suspense'> {
    queryKey: TQueryKey;
    /**
     * Only applicable while rendering queries on the server with streaming.
     * Set `deferStream` to `true` to wait for the query to resolve on the server before flushing the stream.
     * This can be useful to avoid sending a loading state to the client before the query has resolved.
     * Defaults to `false`.
     */
    deferStream?: boolean;
    /**
     * @deprecated The `suspense` option has been deprecated in v5 and will be removed in the next major version.
     * The `data` property on createInfiniteQuery is a SolidJS resource and will automatically suspend when the data is loading.
     * Setting `suspense` to `false` will be a no-op.
     */
    suspense?: boolean;
}
type CreateInfiniteQueryOptions<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey, TPageParam = unknown> = FunctionedParams<SolidInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey, TPageParam>>;
type CreateInfiniteQueryResult<TData = unknown, TError = DefaultError> = InfiniteQueryObserverResult<TData, TError>;
type DefinedCreateInfiniteQueryResult<TData = unknown, TError = DefaultError> = DefinedInfiniteQueryObserverResult<TData, TError>;
interface SolidMutationOptions<TData = unknown, TError = DefaultError, TVariables = void, TContext = unknown> extends OmitKeyof<MutationObserverOptions<TData, TError, TVariables, TContext>, '_defaulted'> {
}
type CreateMutationOptions<TData = unknown, TError = DefaultError, TVariables = void, TContext = unknown> = FunctionedParams<SolidMutationOptions<TData, TError, TVariables, TContext>>;
type CreateMutateFunction<TData = unknown, TError = DefaultError, TVariables = void, TContext = unknown> = (...args: Parameters<MutateFunction<TData, TError, TVariables, TContext>>) => void;
type CreateMutateAsyncFunction<TData = unknown, TError = DefaultError, TVariables = void, TContext = unknown> = MutateFunction<TData, TError, TVariables, TContext>;
type CreateBaseMutationResult<TData = unknown, TError = DefaultError, TVariables = unknown, TContext = unknown> = Override<MutationObserverResult<TData, TError, TVariables, TContext>, {
    mutate: CreateMutateFunction<TData, TError, TVariables, TContext>;
}> & {
    mutateAsync: CreateMutateAsyncFunction<TData, TError, TVariables, TContext>;
};
type CreateMutationResult<TData = unknown, TError = DefaultError, TVariables = unknown, TContext = unknown> = CreateBaseMutationResult<TData, TError, TVariables, TContext>;
type Override<TTargetA, TTargetB> = {
    [AKey in keyof TTargetA]: AKey extends keyof TTargetB ? TTargetB[AKey] : TTargetA[AKey];
};

type UndefinedInitialDataOptions<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> = FunctionedParams<SolidQueryOptions<TQueryFnData, TError, TData, TQueryKey> & {
    initialData?: undefined;
}>;
type DefinedInitialDataOptions<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> = FunctionedParams<SolidQueryOptions<TQueryFnData, TError, TData, TQueryKey> & {
    initialData: TQueryFnData | (() => TQueryFnData);
}>;
declare function queryOptions<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey, TOptions extends ReturnType<UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>> = ReturnType<UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>>>(options: ReturnType<UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>>): ReturnType<UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>> & {
    queryKey: DataTag<TQueryKey, TQueryFnData>;
};
declare function queryOptions<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey, TOptions extends ReturnType<DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>> = ReturnType<DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>>>(options: ReturnType<DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>>): ReturnType<DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>> & {
    queryKey: DataTag<TQueryKey, TQueryFnData>;
};

declare function createQuery<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>, queryClient?: () => QueryClient): CreateQueryResult<TData, TError>;
declare function createQuery<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>, queryClient?: () => QueryClient): DefinedCreateQueryResult<TData, TError>;

declare const QueryClientContext: solid_js.Context<(() => QueryClient) | undefined>;
declare const useQueryClient: (queryClient?: QueryClient) => QueryClient;
type QueryClientProviderProps = {
    client: QueryClient;
    children?: JSX.Element;
};
declare const QueryClientProvider: (props: QueryClientProviderProps) => JSX.Element;

declare function useIsFetching(filters?: Accessor<QueryFilters>, queryClient?: Accessor<QueryClient>): Accessor<number>;

type UndefinedInitialDataInfiniteOptions<TQueryFnData, TError = DefaultError, TData = InfiniteData<TQueryFnData>, TQueryKey extends QueryKey = QueryKey, TPageParam = unknown> = FunctionedParams<SolidInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey, TPageParam> & {
    initialData?: undefined;
}>;
type NonUndefinedGuard<T> = T extends undefined ? never : T;
type DefinedInitialDataInfiniteOptions<TQueryFnData, TError = DefaultError, TData = InfiniteData<TQueryFnData>, TQueryKey extends QueryKey = QueryKey, TPageParam = unknown> = FunctionedParams<SolidInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey, TPageParam> & {
    initialData: NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>> | (() => NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>);
}>;
declare function infiniteQueryOptions<TQueryFnData, TError = DefaultError, TData = InfiniteData<TQueryFnData>, TQueryKey extends QueryKey = QueryKey, TPageParam = unknown>(options: ReturnType<DefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>>): ReturnType<DefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>> & {
    queryKey: DataTag<TQueryKey, InfiniteData<TQueryFnData>>;
};
declare function infiniteQueryOptions<TQueryFnData, TError = DefaultError, TData = InfiniteData<TQueryFnData>, TQueryKey extends QueryKey = QueryKey, TPageParam = unknown>(options: ReturnType<UndefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>>): ReturnType<UndefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>> & {
    queryKey: DataTag<TQueryKey, InfiniteData<TQueryFnData>>;
};

declare function createInfiniteQuery<TQueryFnData, TError = DefaultError, TData = InfiniteData<TQueryFnData>, TQueryKey extends QueryKey = QueryKey, TPageParam = unknown>(options: DefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>, queryClient?: Accessor<QueryClient>): DefinedCreateInfiniteQueryResult<TData, TError>;
declare function createInfiniteQuery<TQueryFnData, TError = DefaultError, TData = InfiniteData<TQueryFnData>, TQueryKey extends QueryKey = QueryKey, TPageParam = unknown>(options: UndefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>, queryClient?: Accessor<QueryClient>): CreateInfiniteQueryResult<TData, TError>;

declare function createMutation<TData = unknown, TError = DefaultError, TVariables = void, TContext = unknown>(options: CreateMutationOptions<TData, TError, TVariables, TContext>, queryClient?: Accessor<QueryClient>): CreateMutationResult<TData, TError, TVariables, TContext>;

declare function useIsMutating(filters?: Accessor<MutationFilters>, queryClient?: Accessor<QueryClient>): Accessor<number>;

type MutationStateOptions<TResult = MutationState> = {
    filters?: MutationFilters;
    select?: (mutation: Mutation) => TResult;
};
declare function useMutationState<TResult = MutationState>(options?: Accessor<MutationStateOptions<TResult>>, queryClient?: Accessor<QueryClient>): Accessor<Array<TResult>>;

type CreateQueryOptionsForCreateQueries<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> = OmitKeyof<SolidQueryOptions<TQueryFnData, TError, TData, TQueryKey>, 'placeholderData' | 'suspense'> & {
    placeholderData?: TQueryFnData | QueriesPlaceholderDataFunction<TQueryFnData>;
    /**
     * @deprecated The `suspense` option has been deprecated in v5 and will be removed in the next major version.
     * The `data` property on createQueries is a plain object and not a SolidJS Resource.
     * It will not suspend when the data is loading.
     * Setting `suspense` to `true` will be a no-op.
     */
    suspense?: boolean;
};
type MAXIMUM_DEPTH = 20;
type SkipTokenForUseQueries = symbol;
type GetOptions<T> = T extends {
    queryFnData: infer TQueryFnData;
    error?: infer TError;
    data: infer TData;
} ? CreateQueryOptionsForCreateQueries<TQueryFnData, TError, TData> : T extends {
    queryFnData: infer TQueryFnData;
    error?: infer TError;
} ? CreateQueryOptionsForCreateQueries<TQueryFnData, TError> : T extends {
    data: infer TData;
    error?: infer TError;
} ? CreateQueryOptionsForCreateQueries<unknown, TError, TData> : T extends [infer TQueryFnData, infer TError, infer TData] ? CreateQueryOptionsForCreateQueries<TQueryFnData, TError, TData> : T extends [infer TQueryFnData, infer TError] ? CreateQueryOptionsForCreateQueries<TQueryFnData, TError> : T extends [infer TQueryFnData] ? CreateQueryOptionsForCreateQueries<TQueryFnData> : T extends {
    queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> | SkipTokenForUseQueries;
    select?: (data: any) => infer TData;
    throwOnError?: ThrowOnError<any, infer TError, any, any>;
} ? CreateQueryOptionsForCreateQueries<TQueryFnData, unknown extends TError ? DefaultError : TError, unknown extends TData ? TQueryFnData : TData, TQueryKey> : CreateQueryOptionsForCreateQueries;
type GetResults<T> = T extends {
    queryFnData: any;
    error?: infer TError;
    data: infer TData;
} ? CreateQueryResult<TData, TError> : T extends {
    queryFnData: infer TQueryFnData;
    error?: infer TError;
} ? CreateQueryResult<TQueryFnData, TError> : T extends {
    data: infer TData;
    error?: infer TError;
} ? CreateQueryResult<TData, TError> : T extends [any, infer TError, infer TData] ? CreateQueryResult<TData, TError> : T extends [infer TQueryFnData, infer TError] ? CreateQueryResult<TQueryFnData, TError> : T extends [infer TQueryFnData] ? CreateQueryResult<TQueryFnData> : T extends {
    queryFn?: QueryFunction<infer TQueryFnData, any> | SkipTokenForUseQueries;
    select?: (data: any) => infer TData;
    throwOnError?: ThrowOnError<any, infer TError, any, any>;
} ? CreateQueryResult<unknown extends TData ? TQueryFnData : TData, unknown extends TError ? DefaultError : TError> : CreateQueryResult;
/**
 * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param
 */
type QueriesOptions<T extends Array<any>, TResult extends Array<any> = [], TDepth extends ReadonlyArray<number> = []> = TDepth['length'] extends MAXIMUM_DEPTH ? Array<CreateQueryOptionsForCreateQueries> : T extends [] ? [] : T extends [infer Head] ? [...TResult, GetOptions<Head>] : T extends [infer Head, ...infer Tail] ? QueriesOptions<[
    ...Tail
], [
    ...TResult,
    GetOptions<Head>
], [
    ...TDepth,
    1
]> : ReadonlyArray<unknown> extends T ? T : T extends Array<CreateQueryOptionsForCreateQueries<infer TQueryFnData, infer TError, infer TData, infer TQueryKey>> ? Array<CreateQueryOptionsForCreateQueries<TQueryFnData, TError, TData, TQueryKey>> : Array<CreateQueryOptionsForCreateQueries>;
/**
 * QueriesResults reducer recursively maps type param to results
 */
type QueriesResults<T extends Array<any>, TResult extends Array<any> = [], TDepth extends ReadonlyArray<number> = []> = TDepth['length'] extends MAXIMUM_DEPTH ? Array<CreateQueryResult> : T extends [] ? [] : T extends [infer Head] ? [...TResult, GetResults<Head>] : T extends [infer Head, ...infer Tail] ? QueriesResults<[
    ...Tail
], [
    ...TResult,
    GetResults<Head>
], [
    ...TDepth,
    1
]> : T extends Array<CreateQueryOptionsForCreateQueries<infer TQueryFnData, infer TError, infer TData, any>> ? Array<CreateQueryResult<unknown extends TData ? TQueryFnData : TData, unknown extends TError ? DefaultError : TError>> : Array<CreateQueryResult>;
declare function createQueries<T extends Array<any>, TCombinedResult extends QueriesResults<T> = QueriesResults<T>>(queriesOptions: Accessor<{
    queries: readonly [...QueriesOptions<T>];
    combine?: (result: QueriesResults<T>) => TCombinedResult;
}>, queryClient?: Accessor<QueryClient>): TCombinedResult;

declare const useIsRestoring: () => Accessor<boolean>;
declare const IsRestoringProvider: solid_js.ContextProviderComponent<Accessor<boolean>>;

export { type CreateBaseMutationResult, type CreateBaseQueryOptions, type CreateBaseQueryResult, type CreateInfiniteQueryOptions, type CreateInfiniteQueryResult, type CreateMutateAsyncFunction, type CreateMutateFunction, type CreateMutationOptions, type CreateMutationResult, type CreateQueryOptions, type CreateQueryResult, type DefaultOptions, type DefinedCreateBaseQueryResult, type DefinedCreateInfiniteQueryResult, type DefinedCreateQueryResult, type DefinedInitialDataInfiniteOptions, type DefinedInitialDataOptions, type FunctionedParams, type InfiniteQueryObserverOptions, IsRestoringProvider, QueryClient, type QueryClientConfig, QueryClientContext, QueryClientProvider, type QueryClientProviderProps, type QueryObserverOptions, type SolidInfiniteQueryOptions, type SolidMutationOptions, type SolidQueryOptions, type UndefinedInitialDataInfiniteOptions, type UndefinedInitialDataOptions, createInfiniteQuery, createMutation, createQueries, createQuery, infiniteQueryOptions, queryOptions, useIsFetching, useIsMutating, useIsRestoring, useMutationState, useQueryClient };
